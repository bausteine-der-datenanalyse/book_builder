{
  "hash": "34a8457296ea83a9d3b499812ca14d4a",
  "result": {
    "engine": "jupyter",
    "markdown": "# Erstellen von NumPy arrays\n\n\n\nTypischerweise werden in Python Vektoren durch Listen und Matrizen durch \ngeschachtelte Listen ausgedrückt. Beispielsweise würde man den Vektor\n\n:::: {layout-ncol=3 layout-valign=\"center\" layout-halign=\"center\"}\n$$\n(1, 2, 3, 4, 5, 6) \n$$\n\n::: {.justify}\nund die Matrix\n:::\n\n$$\n\\begin{pmatrix}\n1 & 2 & 3\\\\\n4 & 5 & 6\n\\end{pmatrix}\n$$\n::::\n\nnativ in Python so erstellen:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nliste = [1, 2, 3, 4, 5, 6]\n\nmatrix = [[1, 2, 3], [4, 5, 6]]\n\nprint(liste)\nprint(matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6]\n[[1, 2, 3], [4, 5, 6]]\n```\n:::\n:::\n\n\nMöchte man jetzt NumPy Arrays verwenden benutzt man den Befehl `np.array()`. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nliste = np.array([1, 2, 3, 4, 5, 6])\n\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(liste)\nprint(matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n```\n:::\n:::\n\n\nBetrachtet man die Ausgaben der `print()` Befehle fallen zwei Sachen auf.\nZum einen fallen die Kommata weg und zum anderen wird die Matrix passend\nausgegeben.\n\nEs gibt auch die Möglichkeit, höherdimensionale Arrays zu erstellen. Dabei \nwird eine neue Ebene der Verschachtelung benutzt. Im folgenden Beispiel wird \neine drei-dimensionale Matrix erstellt.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nmatrix_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\n```\n:::\n\n\nEs gilt als \"good practice\" Arrays immer zu initialisieren. Dafür bietet NumPy \ndrei Funktionen um vorinitialisierte Arrays zu erzeugen. Alternativ können \nArrays auch mit festgesetzten Werten initialisiert werden. Dafür kann entweder \ndie Funktion `np.zeros()`verwendet werden die alle Werte auf 0 setzt, oder aber \n`np.ones()`welche alle Werte mit 1 initialisiert. Der Funktion wird die Form im \nFormat `[Reihen,Spalten]` übergeben. Möchte man alle Einträge auf einen \nspezifischen Wert setzen, kann man den Befehl `np.full()` benutzen.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nnp.zeros([2,3])\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\narray([[0., 0., 0.],\n       [0., 0., 0.]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nnp.ones([2,3])\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\narray([[1., 1., 1.],\n       [1., 1., 1.]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nnp.full([2,3],7)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([[7, 7, 7],\n       [7, 7, 7]])\n```\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n\n## Wie könnte man auch Arrays die mit einer Zahl x gefühlt sind erstellen?\n\nDer Trick beseht hierbei ein Array mit `np.ones()` zu initialisiere und dieses \nArray dann mit der Zahl x zu multiplizieren. Im folgenden Beispiel ist `x = 5`\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nnp.ones([2,3]) * 5\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([[5., 5., 5.],\n       [5., 5., 5.]])\n```\n:::\n:::\n\n\n:::\n\nMöchte man zum Beispiel für eine Achse in einem Plot einen Vektor mit \ngleichmäßig verteilten Werten erstellen, bieten sich in NumPy zwei \nMöglichkeiten. Mit den Befehlen `np.linspace(Start,Stop,#Anzahl Werte)` und \n`np.arrange(Start,Stop,Abstand zwischen Werten)` können solche Arrays erstellt \nwerden.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nnp.linspace(0,1,11)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\narray([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ])\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nnp.arange(0,10,2)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\narray([0, 2, 4, 6, 8])\n```\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n\n## Zwischenübung: Array Erstellung\n\nErstellen Sie jeweils ein NumPy-Array, mit dem folgenden Inhalt:\n\n1. mit den Werten 1, 7, 42, 99\n2. zehn mal die Zahl 5\n3. mit den Zahlen von 35 **bis einschließlich** 50\n4. mit allen geraden Zahlen von 20 **bis einschließlich** 40\n5. eine Matrix mit 5 Spalten und 4 Reihen mit dem Wert 4 an jeder Stelle\n6. mit 10 Werten die gleichmäßig zwischen 22 und einschlieslich 40 verteilt sind\n\n::: {.callout-caution icon=\"false\" collapse=\"true\"}\n\n## Lösung\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# 1. \nprint(np.array([1, 7, 42, 99]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 1  7 42 99]\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# 2. \nprint(np.full(10,5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[5 5 5 5 5 5 5 5 5 5]\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# 3. \nprint(np.arange(35, 51))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50]\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# 4. \nprint(np.arange(20, 41, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[20 22 24 26 28 30 32 34 36 38 40]\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# 5. \nprint(np.full([4,5],4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[4 4 4 4 4]\n [4 4 4 4 4]\n [4 4 4 4 4]\n [4 4 4 4 4]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# 6. \nprint(np.linspace(22, 40, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[22. 24. 26. 28. 30. 32. 34. 36. 38. 40.]\n```\n:::\n:::\n\n\n:::\n\n:::\n\n",
    "supporting": [
      "array_creation_files/figure-pdf"
    ],
    "filters": []
  }
}